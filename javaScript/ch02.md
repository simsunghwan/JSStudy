# 기본 문법 배우기

## 2.1 코드 작성 규칙

### 세미콜론 : 한 문장의 끝을 의미

- 붙여도 되고 안 붙여도 됨
- 가능한 붙이는 것을 추천 (안 붙일 경우 오류 발생의 가능성이 있다)
- 특정 상황에서 세미콜론을 자동 입력하지 않는 경우가 있음

### 주석 : comment

- 한 줄 주석
  - Ctrl + / (VSCode)
- 여러 줄 주석
  - Alt + Shift + A (VSCode)
  - /_ ~~~~~~ _/

### 들여쓰기 : indent

- tab size

## 2.2 자료형 (Data Type)

### 기본 자료형 (Primitive Type)

- string
- number
- boolean
- bigInt
- undefined

### 객체 자료형 (Object Type) : 사용자 정의 자료형

    배열형, null, 사용자 정의 객체(Object)

### 심볼형 (Symbol Type)

### 2.2.1 문자열

- 표현 : ''(따옴표), ""(쌍따옴표).``(백틱)
- 백틱(``)은 내부에 ', ", 변수가 올 수 있다
  - 템플릿 문자열
  - `~개행(\n), ', ", 입력한 대로 문자열 처리`
  - `${변수명}`
- 문자열 내에서 특수한 문자를 표시하기 위해
- Escape Sequence(이스케이프 문자열)
  - \n
  - \t
  - \b
  - \'
  - \"
  - \\
  - '\n'.length : 문자 1개로 취급
- '', "", `` 빈 문자열

- 문자열의 연결(합치기)
  - +연산자 사용
  - 문자열 + 숫자 : 숫자를 문자열 취급(형변환)

## 2.2.2 숫자

- 정수
  - 123
- 실수 (부동소수점)
  - 123.45
  - 1.2345e+2 : 지수표기법
- 진법 표기 숫자
  - 10진수 : 일반적인 숫자표기
  - 2진수 : 0b + '0' 또는 '1' ex) 0b100 == 4
  - 16진수 : 0X + '0~9A~F', 0x + '0~9a~f' 대소문자 섞어서도 사용 가능
  - 8진수 : 0o + '0~7'
- 문자열을 숫자로 바꾸기
  - parseInt(문자열[, 기수]) : 표시 진법에 대한 수 - 16, 8
  - parseFloat(문자열[, 기수])
    - parseInt('123일본') 123
    - parseInt('일본123') NaN
    - parseInt('일123본') NaN
    - parseFloat('123.45') 123.45
    - parseFloat('123.ㅁㅁ45') 123
    - parseFloat('ㅁㅁㅁ123.45') NaN
  - 반환값 = prompt(출력문자열), 반환값의 typeof ---> string
- NaN : Not A Number 숫자가 아님을 나타내는 자바스크립트 리터럴
- 리터럴 (literal) : 구체적인 값
- typeof(NaN) 'number'

- 산술 연산자
  - +, -, \*, /, %
  - ** : 2 ** 4 2의 4승
- Infinity

  - 0을 제외한 숫자를 0으로 나눔
  - typeof Infinity 'number'
  - typeof 1/0 'NaN'

- 오해하기 쉬운 연산자
  - 더하기 연산자(+)
    - 산술 더하기 : 피연산자가 숫자인 경우
    - 문자열 연결하기 : 피연산자가 하나라도 문자열이면 문자열로 변경처리
    - 부호: 단항(피연산자가 하나) 연산 ex) +1, +200
    - 숫자형으로의 형변환 ex) (+true == 1)
  - 빼기 연산자(-)
    - 산술 빼기
    - 문자열 - 숫자 / 숫자 - 문자열 (문자열이 숫자로 구성 된 경우)
    - 부호 : -100
  - 곱하기, 나누기 ( \*, / )

#### 연산자 우선순위 (operator priority)

- (): 20순위 가장 높음
- 같은 레벨의 연산자는 왼쪽이 우선
- 예외: 대입연산자(=)는 오른쪽에 있는 것이 더 우선순위가 높다고 판단

#### 실수 계산시 주의 점

- 32비트로 저장하게 되면서 값의 손실이나 변형되는 문제 ex) 0.01 + 0.09 => 0.09999999999999999

### 2.2.3 불값(boolean)

- true / false
- 숫자로 취급시 1 / 0
- 비교 연산의 결과 / 논리 연산의 결과
- false로 처리되는 경우
  - false
  - 0
  - null
  - undefined
  - NaN
  - '' : 빈 문자열
- true로 처리되는 경우

  - false로 처리되는 경우를 제외한 전부

- 더하기 (+) 연산자를 제외한 대부분의 연산자의 경우 다른 자료형을 비교시 숫자형으로 변경

- NaN과 NaN 비교 // false 동등, 일치 전부
- null과 null 비교 // true 동등, 일치 전부
- undefined 비교 // true 동등, 일치 전부

- 문자열의 비교

  - 문자에 대한 값 : ASCII값(unicode)
  - 'a'.charCodeAt()

- 동등 연산자(==)와 일치 연산자(===)
  - 동일한 점
    - 값을 비교
  - 차이나는 점
    - 데이터 타입 비교 여부
    - 일치 연산자(===)는 Data Type도 비교한다
- != 와 !==

#### 비교 연산자

- <, >, <=, >=, ==, ===, !=, !===

#### 논리 연산자

- && : AND
  - A 이고 B 이면
  - A && B
    - A와 B 모두 true 일때만 true
- || : OR
  - A 또는 B 이면
  - A || B
    - A 또는 B 하나 이상이 true면 true
    - A 와 B 모두 false인 경우 false
    - 엔터키입력? || 탭키 입력?
- ! : NOT

  - A가 아니다
  - !A A값의 역을 반환
  - 100이 아니다
    - a = 100
    - !a

- 논리 연산자와 비교 연산자의 결과 값은 boolean값이다

## 단항 연산자는 오른쪽에서 왼쪽으로 실행 우선 순위를 결정

### 빈값 사용하기

- null
- undefined

- 공통점 : 값이 없다
  - falsy value로 취급 된다
  - undefined == false ===> 결과는 false
  - null == false ===> 결과 false
  - null == 0
- 차이점 :

  - 타입 : null : object == undefined : undefined

- JS : undefined를 기본값으로 취급, 빈값 표현은 undefined를 권장

## 2.3 변수 (Variable)

- 변하는 수, 프로그램 실행시 임시로 데이터를 저장하는 데이터 장소
- 관례 : 변수는 선언 및 초기화 후 사용하는 것을 권장

### 1) 선언 (Declaration)

- var : 옛날 버전의 변수 선언 키워드
  - 특성
    - 같은 변수명으로 여러번 선언이 가능하다
    -
- let :
- const : 상수 (constant)
  - 변하지 않는 수
  - const로 선언문을 사용할 경우 초기화 하지 않으면 에러
  - const로 선언한 상수에 값 쓰기 금지
- let 변수명; // 선언문

* 변수명/상수명

  - $, \_, 문자(유니코드로 가능), 숫자
  - 숫자로 시작할 수 없다
  - JS의 키워드는 사용할 수 없다

* 선언만한다면 변수는 undefined값을 가진다

### 2) 초기화 (initialization)

- 변수 선언시 값을 대입하는 행위
- let 변수명 = 초기값;
  - 초기값 : 리터럴, 식 (expression, 연산자와 피연산자로 구성 됨)

### 3) 사용

#### 3-1) 읽기

- 변수명

#### 3-2) 쓰기(입력)

- 변수명에 대입연산

> 문, 식
>
> - 문(statement) : 선언문,조건문, 반복문 등의 문장, 해당하는 문장에 대한 실행
> - 식(expression) : 수식 등을 말하고, 실행 + 결과

## 2.4 조건문

```javascript
// if문

if(조건식) {
    내용1;
    [내용2;
    ...]
    }

// if ~else문

if(조건식) {
    내용1;
    [내용2;
    ...]
    } else if {
    내용e1;
    [내용e2;
    ...]
}

// if ~else if ~else 문

-   if(조건식) {
    내용1;
    [내용2;
    ...]
    } else if {
    내용e1;
    [내용e2;
    ...]
    } else {
    내용le1
    [내용e2;
    ...]
    }
```

### 중첩 조건문 : nested condition statement

- 내포된 if
- 조건문 내부에 조건문이 존재하는 경우
- 중첩 if 문은 피하는 것이 좋다(중첩의 깊이가 깊어지면 가독성이 떨어진다)

### switch문

```js
    switch(수식){
        case 값:    // 수식 === 값1 true인 경우
            실행문들;
            [break;] // break를 만날 때까지 실행
        case 값2:
            실행문들;
            break;
        ...
        default:
            실행문들;
// 예시
let value = 'B';
switch (value) {
    case 'A':
        console.log('A');
        break;
    case 'B':
        console.log('B');
        break;
    case 'C':
        console.log('C');
        break;
}
    }
```

#### break문

- 반복문에서도 사용
  - block : { ~ } 형태의 코드
- 현재 실행중인 block을 중단하는 문장
- 실행의 범위
  - break문이 속해있는 block 하나만 중단
  - for() { for() { break; } }

#### continue문

- 중단
- continue문이 실행되면 바로 조건문 검사를 실행함

### 3항 연산자 : 조건부 연산자

- 조건식 ? ( 참인경우 실행할 문장 / 식) : ( 거짓인 경우 실행할 문장 / 식 )

## 2.5 반복문

### while

```js
-   while(조건식) {
        실행문1;
        [실행문2;
        ...]
    }
    // 조건식이 만족하는 동안(true인 동안) 블럭 내의 문장 실행

-   조건식을 만족시킬 수 있는 문장; // (1)
    while(조건식) {  // (2)
        문장들;
        ...
        조건식의 값에 변화에 영향을 끼치는 문장;    // (3)
    }
```

### do wile

- do {  
  문자들;  
  ...  
  } while(조건식);
- 무조건 조건식을 한번은 실행함

### for

- for([초기식]; [조건식]; [변화식]) {  
  문장들;  
  ...  
  }
- 초기식(1)
- 조건식(2)
- 문장 실행
- 변화식(3)

#### for in

#### for of

### 중첩반복문 (nested loop)

- 반복문 안에 반복문이 있는 경우
- 이중 반복문, 3중 반복문, ...

## 2.6 객체 (object)

- js 데이터 타입의 일종
- 배열, 함수, 그외 정의해나가는 자료(객체)

### 배열(Array)

- 나열할 수 있는 데이터를 집중적으로 관리할 수 있는 데이터 타입
- 나열가능한 데이터
  - 배열, 객체, 프리미티브 타입, null, undefined, Infinity, NaN
- 데이터의 중복 가능, 순서 상관없음
- 요소(Element) : 배열에 저장되는 하나의 데이터
- 인덱스(Index) : 특정한 요소의 저장위치

#### 1) 선언 / 정의

- [요소1, 요소2, ...] : 대괄호를 사용
- Array() 사용 : Array객체의 생성자를 사용
  - new Array(숫자) : 빈 배열을 숫자만큼 생성
  - new Array(요소1, 요소2, 요소3)
- 배열내에 배열요소가 저장되도록 한것 : 다중배열(다차원 배열), 2중 배열(2차원 배열)

#### 2) 사용

- 배열의 크기(길이) : 배열명.length;
  - 가장 마지막 요소의 인덱스 : 배열명.length - 1
- 읽기
  - 배열명[인덱스 번호]
- 쓰기
  - 배열명[인덱스 번호] = 쓸값
- 수정
  - 배열명[인덱스 번호] = 수정값
- 삭제
  - delete 배열명[인덱스 번호]
    - 해당요소 empty
    - 배열의 길이는 변하지 않는다
- 가장 앞에 추가
  - 배열명.unshift(추가값[, 추가값2]) 여러개도 가능
- 가장 마지막에 추가
  - 배열명[배열명.length] = 추가값
  - 배열명.push(추가값[, 추가값2])여러개도 가능
- 가장 앞에서 삭제
  - 배열명.shift() : 삭제한 요소를 반환 ()에 숫자를 써도 의미가 없다
  - 배열의 길이가 변화
- 가장 마지막에 삭제
  - 배열명.pop() : 삭제한 요소를 반환 ()에 숫자를 써도 의미가 없다
  - 배열의 길이가 변화
- 삽입과 삭제
  - 배열명.splice(시작index, [삭제요소개수, 추가할 요소들])
  - 배열명.splice(시작index)
    - 시작index에서 배열끝까지 삭제
  - 배열명.splice(시작index, 삭제요소개수)
    - 시작index에서 지정한 개수만큼 삭제
  - 배열명.splice(시작index, [삭제요소개수, 추가할 요소들])
    - 시작 index에서 지장한 갯수만큼 삭제하고, 추가요소 삽입
- 검색
  - 배열명.includes(검색할 요소);
    - 반환값 : boolean
    -
  - 배열명.indexOf(검색할 요소);
    - 반환값 : index값
    - 가장 앞부터 검사하여 가장 처음 발견된 요소
    - 해당 요소가 없다면 -1을 반환
  - 배열명.lastIndexOf(검색할 요소);
    - 반환값 : index 값
    - 가장 마지막부턱 검사하여 가장 처음 발견된 요소
    - 해당 요소가 없다면 -1을 반환
- 반복
  - for
  - for..in문 사용
    - for( let key in 배열명)
  - 배열명.forEach(함수)

### 함수(function)

- 특정한 기능을 수행하는 코드들의 집합
- 비유 : 자판기

#### 1) 정의 / 선언

- 선언문
  - function 함수명(파라미터 리스트) { // 함수의 시그니처, 함수의 헤더  
     // 중괄호 부분 : 함수의 바디  
    }
- 표현식 (expression) : 대입 연산자(=) , this 객체의 의미가 선언문과 달라짐
  - 이름없는 선언문
    - const 상수명 = function(파라미터 리스트){ }; // 호출은 상수명(아규먼트리스트)
  - 화살표함수(arrow function)
    - const 상수명 = (파라미터리스트) => {};

#### 2) 호출

- 함수명(아규먼트 리스트)
- 상수명(아규먼트 리스트)
- 호출하면 반드시 결과를 반환함

#### 3) 파라미터(parameter)/아규먼트(argument)

- 파라미터 : 가인수(매개변수)
  - 함수선언시 함수 헤더에 나오는 인수
- 아규먼트 : 실인수(인수,인자)
  - 함수 호출시 사용하는 인수

#### 4) 반환

- return [데이터(변수, 리터럴)];
- return을 명시하지 않은 경우 return undefined; 가장 마지막에 실행
  - 함수 내부에서 return문을 실행하는 경우 함수실행 중지
  - 함수 호출한 다음 위치로 이동후 사용
  -

#### 5) 함수내의 사용 변수 : scope

- 전역변수 : 함수 내외부에서 사용가능
- 지역변수 : 함수 내에서만 사용가능
- 파라미터 : 지역변수 취급

#### 순수함수

- 파라미터와 지역변수/상수만으로 구현한 함수

### 함수선언과 화살표 함수 비교

- function add(x, y) { return x + y; }
- const add2 = function(x, y) { return x + y; };
- const add3 = (x, y) => { return x + y; };
- const add4 = (x, y) => x + y;  
  // 함수 실행문이 return만 존재하는 경우 중괄호와 return을 생략할 수 있다
- const add5 = (x, y) => (x + y);
- const not = x => !x; // 파라미터가 하나인 경우 소괄호 생략가능 not(test)
- 주의사항 : this의 의미가 달라진다
- 주의사항 : 화살표 함수 내에선 argument를 사용하지 못함

### object literal(객체 리터럴)

- 자바 스크립트는 OOP기반언어가 아니다 프로토타입 기반의 언어
- 객체 : 어떤 특성을 가지는 대상에 대한 여러 변수를 하나의 데이터로 묶은 것

#### 정의/선언/초기화

- const 객체명 = { // 키값1: 값1, 키값2: 값2, ..., 키n: 값n,  
   속성명1: 속성값1, //property(속성)  
   속성명2: 속성값2,  
   ...,  
   속성명n: 속성값n[,]  
  };
- 속성명 : 문자열 또는 심볼 지정
- 속성값 : 모든 data type들
- 속성값이 함수인 경우 : 메소드(method) : 객체 내에 정의된 함수
  - ex) console.log('문자열');

#### 사용법

- . 연산자 이용법
  - 객체명.속성명 : 읽기
  - 객체명.속성명 = 값 : 쓰기 / 수정
  - 객체명.속성명(인수들)
- 연관배열이용법
  - 객체명['속성명']
    - 객체명['속성명'] : 읽기
    - 객체명['속성명'] = 값; : 쓰기 / 수정
  - 메소드 호출 불가
- 속성 삭제
  - delete 객체명.속성명;
  - delete 객체명['속성명'];

#### 연관배열

- Associated Array
- 연상배열(?)찾아보기
- 연관배열의 index : 문자열

#### 객체간 비교/참조/복사

- 비교
  - {} == {}, {} === {} ==> false
- 참조(reference)
  - 객체에 대한 변수는 해당 객체의 참조값을 저장
  - 참조값: 메모리에서의 주소값
  - primitive type의 변수 : 실제 리터럴 값이 저장됨
    - let a = 'jit';
    - 메모리(stack 메모리)에 값을 저장시킨 후 변수로 별명처럼 사용
- 객체의 복사
  - 단순 대입으로는 불가
  - const a ={}; const c = a;
    - 참조값의 복사로 a, c는 같은 객체를 참고한다(객체의 복사가 일어나지 않았다)
    - clone() 이용해서 복사
